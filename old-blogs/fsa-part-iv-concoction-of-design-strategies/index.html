---
layout: post
title: FSA Part IV - Concoction of design-strategies | Ritu Kundu
coltype: no-sidebar
---
<div id="primary" class="featured-content content-area"><main id="main" class="site-main">
<article id="post-2696" class="posts-entry fbox post-2696 post type-post status-publish format-standard has-post-thumbnail hentry category-algorithm-design-and-analysis">
	<div class="featured-thumbnail">
		<a href="/old-blogs/fsa-part-iv-concoction-of-design-strategies/" rel="bookmark"><img width="321" height="137" src="https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?fit=321%2C137&ssl=1" class="attachment-minimalistblogger-slider size-minimalistblogger-slider wp-post-image" alt="" decoding="async" srcset="https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?w=321&ssl=1 321w,https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?resize=300%2C128&ssl=1 300w" sizes="(max-width: 321px) 100vw, 321px"></a>
	</div>
	<header class="entry-header">
		<h1 class="entry-title">FSA Part IV: Concoction of design-strategies</h1>
		<div class="entry-meta"><div class="blog-data-wrapper">
			<div class="post-data-divider"></div>
			<div class="post-data-positioning"><div class="post-data-text">
				<span class="posted-on">Posted on <a href="/old-blogs/fsa-part-iv-concoction-of-design-strategies/" rel="bookmark"><time class="entry-date published updated" datetime="2017-12-28T03:07:35+00:00">December 28, 2017</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="https://ritu-kundu.github.io/author/rituritukundugmailcom/">Ritu Kundu</a></span></span>
			</div></div>
		</div></div>
	</header>

	<div class="entry-content">
		<p style="text-align:justify;">Again, this post is meant specifically for undergraduate students (<em>first timers into automata theory</em>) – a very brief introduction of FSA: Finite State Automaton (Automata when <em>plural</em>). This post is the third of four parts: the <a href="/old-blogs/fsa-concoction-of-design-strategies/">first</a> part covers an elementary introduction to FSA and DFA (Deterministic Finite Automaton), the <a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/" target="_blank" rel="noopener">second</a> part encompasses some common examples illustrating design-strategies for constructing DFA, the <a href="/old-blogs/fsa-part-iii-concoction-of-design-strategies/">third</a> part provides an introduction to NFA (Nondeterministic Finite Automaton) and its equivalence with DFA, and this part introduces the Pumping Lemma and its usage in the context of FSA.</p>
<p style="text-align:justify;">This part delves only into the application of the pumping lemma to prove that a language is NOT regular. It does not cover the properties of Regular languages or inter-conversion of FSA and the regular expressions.</p>
<hr>
<hr>
<h1 style="text-align:justify;">Regular Languages:</h1>
<p style="text-align:justify;">Recall that a language is simply a set of sequences (or strings) over an alphabet. This set can be finite or infinite making the language finite or infinite accordingly. For instance, let L1 = {“00”, “01”}, L2 = {0<sup>k</sup> |0 ≤ k ≤ 4}, and L3 = {0<sup>k</sup> | k ≥ 0} be three languages over an alphabet Σ = {0, 1}. Here, L1 is a set of only two strings — “00” and “01”; L2 is a set of five strings — ε (empty string when k = 0), “0” (when k=1), “00” (when k=2), , “000” (when k=3), , “0000” (when k=4);   and L3 is a set of infinite strings i.e. {ε, “0”, “00”, “000”, “0000”, ….}. Consequently, L1 and L2 are finite languages whereas L3 is infinite.</p>
<p style="text-align:justify;">There are different criteria based on which languages can be classified. The class of languages that can be expressed by finite automata (recall that DFA and NFA are equivalent in terms of their <em>expressive</em> power, see <a href="/old-blogs/fsa-part-iii-concoction-of-design-strategies/">Part III</a>), is called <em><strong>Regular</strong></em>. Simply, a language L is regular if an automaton M can be constructed which accepts all sequences of L and rejects all other sequences (i.e. those in its complement L<sup>C</sup>).</p>
<p style="text-align:justify;">Now the question arises – How to identify whether a given language L is regular or not? If we can construct a DFA for it, it definitely is regular. What if we can not build a DFA? Does it mean that no DFA is possible for L implying that L is not regular? Or is it the case that a DFA may be  possible but we do not know how to define it. This is where Pumping Lemma comes to our rescue.</p>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>It is to make explicit that a finite language can always be expressed by a finite automaton. It may be practically an unwieldy FSA with scores of states, still theoretically it is possible. Resultantly, every finite language is a regular language.</em></p>
<h1 style="text-align:justify;"></h1>
<hr>
<hr>
<h1 style="text-align:justify;">Pumping Lemma:</h1>
<p style="text-align:justify;">The pumping lemma specifies a vital property exhibited by a regular language. There are many variants, correspondingly various formal statements, of the pumping lemma. The one we will use is as follows:</p>
<blockquote><p>If <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is an <strong>infinite</strong> regular language, then there exists some <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex"> in <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma%5E%2A&bg=ffffff&fg=000&s=0" alt="\Sigma^*" title="\Sigma^*" class="latex"> such that<br>
<img decoding="async" src="//s0.wp.com/latex.php?latex=y+%5Cneq+%5Cepsilon&bg=ffffff&fg=000&s=0" alt="y \neq \epsilon" title="y \neq \epsilon" class="latex"><br>
<img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Enz+%5Cin+L+%5Ctext%7B+for+%7D+n+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="xy^nz \in L \text{ for } n \geq 0" title="xy^nz \in L \text{ for } n \geq 0" class="latex"></p></blockquote>
<p style="text-align:justify;">Note that this definition takes into account only an infinite language which is regular. If that is the case then there exists some string x, y, and z over the alphabet of the language such that y is not empty and all the strings of the form x.z, x.y.z, x.y<sup>2</sup>.z (which is same as x.y.y.z), x.y<sup>3</sup>.z (or x.y.y.y.z) , and so on are in that language. Recall that “.” (dot) represents concatenation.</p>
<p style="text-align:justify;">The important point to understand here is that if L is regular and infinite language then there will be some string x, y, z such that we can keep pumping (increasing power of) y (which is non-empty) in x.y.z so that all such strings obtained after pumping will be in L. That’s it. It doesn’t say anything at all about how to find those x, y, and z or what if we have found them; having found some x, y, z that satisfy these conditions does not mean that the language is regular. In other words, the converse of this statement is not true.</p>
<p style="text-align:justify;">Let’s take an example to understand what the statement really implies. Consider a language L over alphabet {0, 1} such that <img decoding="async" src="//s0.wp.com/latex.php?latex=L+%3D+%5C%7Bx+%7C+x+%5Cin+%5CSigma%5E%2A+%5Ctext%7B+and+%7D+%7Cx%7C+%5Ctext%7B+is+odd%7D+%5C%7D&bg=ffffff&fg=000&s=0" alt="L = \{x | x \in \Sigma^* \text{ and } |x| \text{ is odd} \}" title="L = \{x | x \in \Sigma^* \text{ and } |x| \text{ is odd} \}" class="latex"> i.e. L is a language of all strings of 0s and 1s whose length is odd (L = {“0”, “1”,”111″,”000″,”001″,”010″, …. }). It is an infinite language and is regular. Following is its automaton (refer to <a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/">Post II</a> to see how we can construct it):</p>
<blockquote><p><img fetchpriority="high" decoding="async" class="  wp-image-2453 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?resize=470%2C123&ssl=1" alt="DFA_Eg_OddLen" width="470" height="123" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?w=611&ssl=1 611w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?resize=300%2C79&ssl=1 300w" sizes="(max-width: 470px) 100vw, 470px" data-recalc-dims="1"></p></blockquote>
<p style="text-align:justify;">There may be multiple x, y, z that satisfy the pumping lemma for L (which is an infinite regular language): one such tuple is x= “0”, y=”01″, z=”00″. Here, x.z (0.00 = “000”) is in L (as it has length 3); so is x.y.z (0.01.00 = “00100”) with length 5; and so is x.y<sup>2</sup>.z (0.01.01.00 = “0010100”) with length 7; and it goes on. In fact, any x and y such that there combined length is odd and a y whose length is even will satisfy the pumping lemma for this language — we can keep pumping y of even length => resulting pumped up y will be of even length, but |x| + |z| is odd => total length of xy<sup>n</sup>z is odd (even + odd = odd).</p>
<h2 style="text-align:justify;">Application –</h2>
<p style="text-align:justify;">Pumping lemma simply states a property of a regular language; it does not claim that if that property is exhibited by some language then that language will be regular. So, the property (as noted in the pumping lemma) can not be used to prove the regularity of a language. However, if we can prove that no x, y, z fulfilling the property can exist for a language, that would mean that the language is <strong>not regular</strong>. Therefore, the pumping lemma finds its application in proving that a language is <em><strong>non-regular</strong></em>.</p>
<p style="text-align:justify;">There are two approaches to attack the problem of proving a language is non-regular using the pumping lemma; I call them <em>direct</em> and <em>indirect</em>. The direct approach is used when the sequence in the language has some <em>shape</em> (or <em>structure</em> or <em>pattern</em>); whereas, the indirect approach comes handy where no such structure in the sequences can be identified.</p>
<p style="text-align:justify;">Nevertheless, both the approaches work on the lines of <strong>proof by contradiction</strong>. We begin by assuming that the given infinite language, say L, is regular. In the direct approach, we prove that no x,y, z over <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma%5E%2A&bg=ffffff&fg=000&s=0" alt="\Sigma^*" title="\Sigma^*" class="latex"> are possible using which we can pump up y (non-empty) and have the pumped up string in L. It is in contradiction to Pumping Lemma which guarantees that some such x, y, z do exist if L is regular, which in turn forces us to conclude that our assumption is wrong. Thus, we prove L is non-regular.</p>
<p style="text-align:justify;">Likewise in the indirect approach, we begin by making an assumption that the infinite language L is regular. Then, we try to use the following property of regular languages (it’s is called <em>closure under the intersection</em>):</p>
<blockquote>
<p style="text-align:justify;">If L1 and L2 are two regular languages then so is their intersection (ie. L1 ∩ L2 will be regular).</p>
</blockquote>
<p style="text-align:justify;">How do we proceed now? We have already assumed that L is regular. But L does not have a structure. So we try to come up with another regular language say L’, which has some kind of structure. When we take their intersection, L” = L ∩ L’ will adopt the same structure. Since, L” has some structure, we can use Pumping lemma to prove it is non-regular (making use of the direct approach on it). But following the above property, the language L” ( = L ∩ L’) must be regular. What went wrong? The answer is our assumption that L is regular. L” is not regular and L’ is definitely regular. It only means that L can not be regular.</p>
<hr>
<hr>
<h1 style="text-align:justify;">Examples:</h1>
<h2>Direct Approach –</h2>
<h3 style="text-align:justify;"><i>Language 0<sup>i</sup>1<sup>i</sup></i></h3>
<p style="text-align:justify;"><strong>Problem 1:</strong><em> Let <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> be a language </em><em>over an alphabet <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma+%3D+%5C%7B0%2C+1%5C%7D&bg=ffffff&fg=000&s=0" alt="\Sigma = \{0, 1\}" title="\Sigma = \{0, 1\}" class="latex"></em>, <i>such that <img decoding="async" src="//s0.wp.com/latex.php?latex=L+%3D+%5C%7B0%5Ei1%5Ei+%7C+i+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L = \{0^i1^i | i \geq 1\}" title="L = \{0^i1^i | i \geq 1\}" class="latex">. Is <em><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> regular?</em></i></p>
<h4>Example</h4>
<p style="text-align:justify;">Here <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> = {“01”, “0011”, “000111”, … }. <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is an infinite language which is a set of sequences consisting of a certain number of 0s followed by the same number of 1s. Note that the number itself is a variable. But L has a structure: All zeroes in the beginning, followed by all 1s.</p>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>A rule of thumb: An FSA can not make an arbitrary number of comparisons. Any language that needs comparing a variable number of symbols, will not be regular. </em></p>
<h4 style="text-align:justify;">Proof</h4>
<p style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is infinite. Let us assume that <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is regular. Then according to the pumping lemma, there must exist some <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex"> in <img decoding="async" src="//s0.wp.com/latex.php?latex=%5C%7B0%2C1%5C%7D%5E%2A&bg=ffffff&fg=000&s=0" alt="\{0,1\}^*" title="\{0,1\}^*" class="latex"> such that <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> is non-empty and <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Enz+%5Cin+L+%5Ctext%7B+for+%7D+n+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="xy^nz \in L \text{ for } n \geq 0" title="xy^nz \in L \text{ for } n \geq 0" class="latex">. Every string in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is of the form: all 0s followed by an equal number of 1s (i.e. 00000….0011111….11). If we try to split up such a string in <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex">, then a non-empty <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> can take a form from one of the following possibilities: all 0s, all 1s, some 0s followed by some 1s.</p>
<p><img decoding="async" class=" size-full wp-image-2704 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?resize=321%2C137&ssl=1" alt="PL" width="321" height="137" srcset="https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?w=321&ssl=1 321w,https://ritu-kundu.github.io/assets/uploads/2017/12/pl.png?resize=300%2C128&ssl=1 300w" sizes="(max-width: 321px) 100vw, 321px" data-recalc-dims="1"></p>
<p style="text-align:justify;">Now we will show that any of the three types of <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> when pumped up will result in a string that can not be a member of <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> because either the <em>balance </em>(of the number of 0s and 1s) or the <em>structure</em> gets violated by pumping.</p>
<ul>
<li style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5El&bg=ffffff&fg=000&s=0" alt="y = 0^l" title="y = 0^l" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=l+%5Cgeq+1&bg=ffffff&fg=000&s=0" alt="l \geq 1" title="l \geq 1" class="latex">. Then <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in more 0s than 1s (violating the balance of 0s and 1s); therefore, such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</li>
<li style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+1%5Em&bg=ffffff&fg=000&s=0" alt="y = 1^m" title="y = 1^m" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=m+%5Cgeq+1&bg=ffffff&fg=000&s=0" alt="m \geq 1" title="m \geq 1" class="latex">. Then <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in more 1s than 0s (violating the balance of 0s and 1s); therefore, such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</li>
<li style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5Ep1%5Eq&bg=ffffff&fg=000&s=0" alt="y = 0^p1^q" title="y = 0^p1^q" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=p%2Cq+%5Cgeq+1&bg=ffffff&fg=000&s=0" alt="p,q \geq 1" title="p,q \geq 1" class="latex">. Then any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in a string of 0s, followed by <img decoding="async" src="//s0.wp.com/latex.php?latex=2+%28or%7E+i%29&bg=ffffff&fg=000&s=0" alt="2 (or~ i)" title="2 (or~ i)" class="latex"> copies of <img decoding="async" src="//s0.wp.com/latex.php?latex=0%5Ep1%5Eq&bg=ffffff&fg=000&s=0" alt="0^p1^q" title="0^p1^q" class="latex">, followed by 1s (i.e. <img decoding="async" src="//s0.wp.com/latex.php?latex=000....0%5Ep1%5Eq0%5Ep1%5Eq.....11111&bg=ffffff&fg=000&s=0" alt="000....0^p1^q0^p1^q.....11111" title="000....0^p1^q0^p1^q.....11111" class="latex"> which destroys the structure); such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.Hence, there is no <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> possible that can satisfy the pumping lemma for this language. Thus, <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is not regular.</li>
</ul>
<hr>
<h3><i>Language 0<sup>i</sup>1</i><i>0<sup>i</sup>1</i></h3>
<p><strong>Problem 2:</strong><em> Let <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> be a language </em><em>over an alphabet <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma+%3D+%5C%7B0%2C+1%5C%7D&bg=ffffff&fg=000&s=0" alt="\Sigma = \{0, 1\}" title="\Sigma = \{0, 1\}" class="latex"></em>, <i>such that <img decoding="async" src="//s0.wp.com/latex.php?latex=L+%3D+%5C%7B0%5Ei10%5Ei1+%7C+i+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L = \{0^i10^i1 | i \geq 1\}" title="L = \{0^i10^i1 | i \geq 1\}" class="latex">. Is <em><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> regular?</em></i></p>
<h4>Example</h4>
<p style="text-align:justify;">Here <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> = {“0101”, “001001”, “00010001”, … }. <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">  is an infinite language which is a set of sequences consisting of a certain number of 0s followed by 1, then followed by the same number of 0s which in turn ends with a 1. L has a structure: A segment of all zeroes in the beginning, then a 1 followed by another segment of 0s which is followed by another 1.</p>
<h4>Proof</h4>
<p style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is infinite. Let us assume that <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is regular. Then according to the pumping lemma, there must exist some <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex"> in <img decoding="async" src="//s0.wp.com/latex.php?latex=%5C%7B0%2C1%5C%7D%5E%2A&bg=ffffff&fg=000&s=0" alt="\{0,1\}^*" title="\{0,1\}^*" class="latex"> such that <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> is non-empty and <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Enz+%5Cin+L+%5Ctext%7B+for+%7D+n+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="xy^nz \in L \text{ for } n \geq 0" title="xy^nz \in L \text{ for } n \geq 0" class="latex">. Every string in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> has the above-mentioned form.:  00000….00100000….001). If we try to split up such a string in <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex">, then a non-empty <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> can take a form from one of the following possibilities: all 0s, zero or more 0s followed by a 1 followed by zero or more 0s, zero or more 0s followed by a 1 followed by all 0s of the second segment followed by 1.</p>
<p><img loading="lazy" decoding="async" class=" size-full wp-image-2705 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/12/pl2.png?resize=321%2C219&ssl=1" alt="PL2" width="321" height="219" srcset="https://ritu-kundu.github.io/assets/uploads/2017/12/pl2.png?w=321&ssl=1 321w,https://ritu-kundu.github.io/assets/uploads/2017/12/pl2.png?resize=300%2C205&ssl=1 300w" sizes="(max-width: 321px) 100vw, 321px" data-recalc-dims="1"></p>
<p style="text-align:justify;">Now we will show that any of the three types of <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> when pumped up will result in a string that can not be a member of <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> because either the <em>balance </em>(number of 0s in the two segments) or the <em>structure</em> is violated by pumping.</p>
<ul>
<li style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5El&bg=ffffff&fg=000&s=0" alt="y = 0^l" title="y = 0^l" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=l+%5Cgeq+1&bg=ffffff&fg=000&s=0" alt="l \geq 1" title="l \geq 1" class="latex">. This comes from either the first or the second segment. Then <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in more 0s in that segment than the other (violating the balance of 0s in the two segments); therefore, such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</li>
<li><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5Ep10%5Eq&bg=ffffff&fg=000&s=0" alt="y = 0^p10^q" title="y = 0^p10^q" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=p%2Cq+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="p,q \geq 0" title="p,q \geq 0" class="latex">. Then any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in a string of 0s, followed by <img decoding="async" src="//s0.wp.com/latex.php?latex=2+%28or%7E+i%29&bg=ffffff&fg=000&s=0" alt="2 (or~ i)" title="2 (or~ i)" class="latex"> copies of <img decoding="async" src="//s0.wp.com/latex.php?latex=0%5Ep10%5Eq&bg=ffffff&fg=000&s=0" alt="0^p10^q" title="0^p10^q" class="latex">, followed by 0s and a 1 (i.e. <img decoding="async" src="//s0.wp.com/latex.php?latex=000....0%5Ep10%5Eq0%5Ep10%5Eq.....0001&bg=ffffff&fg=000&s=0" alt="000....0^p10^q0^p10^q.....0001" title="000....0^p10^q0^p10^q.....0001" class="latex"> which destroys the structure); such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</li>
<li>
<p style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5Ep10%5Eq1&bg=ffffff&fg=000&s=0" alt="y = 0^p10^q1" title="y = 0^p10^q1" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=p+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="p \geq 0" title="p \geq 0" class="latex"> and <img decoding="async" src="//s0.wp.com/latex.php?latex=q&bg=ffffff&fg=000&s=0" alt="q" title="q" class="latex"> is the number of 0s in the second segment. Then any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in a string of 0s, followed by <img decoding="async" src="//s0.wp.com/latex.php?latex=2+%28%7Eor%7E+i%29&bg=ffffff&fg=000&s=0" alt="2 (~or~ i)" title="2 (~or~ i)" class="latex"> copies of <img decoding="async" src="//s0.wp.com/latex.php?latex=0%5Ep10%5Eq1&bg=ffffff&fg=000&s=0" alt="0^p10^q1" title="0^p10^q1" class="latex">, followed by 0s and a 1 (i.e. <img decoding="async" src="//s0.wp.com/latex.php?latex=000....0%5Ep10%5Eq10%5Ep10%5Eq1&bg=ffffff&fg=000&s=0" alt="000....0^p10^q10^p10^q1" title="000....0^p10^q10^p10^q1" class="latex"> which destroys the structure); such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</p>
<p style="text-align:justify;">Hence, there is no <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> possible that can satisfy the pumping lemma for this language. Thus, <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is not regular.</p>
</li>
</ul>
<hr>
<h2>Indirect Approach –</h2>
<h3><i>Language of equal number of 0s and 1s</i></h3>
<p style="text-align:justify;"><strong>Problem 3:</strong><em> Let <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> be a language </em><em>over an alphabet <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma+%3D+%5C%7B0%2C+1%5C%7D&bg=ffffff&fg=000&s=0" alt="\Sigma = \{0, 1\}" title="\Sigma = \{0, 1\}" class="latex"></em>, <i>such that <img decoding="async" src="//s0.wp.com/latex.php?latex=L+%3D+%5C%7B+x+%7C+x+%5Cin+%5C%7B+0%2C+1%5C%7D%5E%2A+%5Ctext+%7B+and+x+has+equal+number+of+0s+and+1s%7D+%5C%7D&bg=ffffff&fg=000&s=0" alt="L = \{ x | x \in \{ 0, 1\}^* \text { and x has equal number of 0s and 1s} \}" title="L = \{ x | x \in \{ 0, 1\}^* \text { and x has equal number of 0s and 1s} \}" class="latex">. Is <em><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> regular?</em></i></p>
<h4>Example</h4>
<p style="text-align:justify;">Here <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> = {“01”, “10”, “0011”, “0101”, “1010, “1100”, “1001”, … }. <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">  is an infinite language which is a set of sequences consisting of 0s and the same number of 1s but in no definite pattern. Here L has no structure: a sequence can take any form. Thus, we will go by the indirect approach.</p>
<h4 style="text-align:justify;">Proof</h4>
<p style="text-align:justify;">Let us assume that <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is regular. Consider another language <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27+%3D+%5C%7B0%5Ep1%5Eq+%7C+p%2Cq+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L' = \{0^p1^q | p,q \geq 1\}" title="L' = \{0^p1^q | p,q \geq 1\}" class="latex">. <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27&bg=ffffff&fg=000&s=0" alt="L'" title="L'" class="latex"> is a language consisting of sequences which takes the form: some 0s followed by some 1s. Note that it doesn’t require 0s and 1s to be equal. It is a regular language as the following automaton (DFA) accepts it.</p>
<p style="text-align:justify;"><img loading="lazy" decoding="async" class="  wp-image-2706 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/12/pl3.png?resize=297%2C183&ssl=1" alt="PL3" width="297" height="183" srcset="https://ritu-kundu.github.io/assets/uploads/2017/12/pl3.png?w=427&ssl=1 427w,https://ritu-kundu.github.io/assets/uploads/2017/12/pl3.png?resize=300%2C185&ssl=1 300w" sizes="(max-width: 297px) 100vw, 297px" data-recalc-dims="1"></p>
<p style="text-align:justify;">As L is a language with equal number of 0s and 1s and L’ is a language of 0s followed by 1s. The language resulting from the intersection of these two, say L”, consists of sequences with 0s followed by equal number of 1s. In other words <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27%27+%3D+L+%5Ccap+L%27+%3D+%5C%7B0%5Ei1%5Ei+%7C+i+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L'' = L \cap L' = \{0^i1^i | i \geq 1\}" title="L'' = L \cap L' = \{0^i1^i | i \geq 1\}" class="latex">. L’ is regular (shown by the DFA) and as per our assumption, L is also regular. Then according to the closure property under intersection, L” should also be regular.</p>
<p style="text-align:justify;">But in Problem 1 we have shown that L” is not regular using the pumping lemma. Therefore, our assumption about L that it is regular is wrong. Hence, L is non-regular.</p>
<hr>
<h3><i>Language ww<sup>R</sup></i></h3>
<p style="text-align:justify;"><strong>Problem 3:</strong><em> Let <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> be a language </em><em>over an alphabet <img decoding="async" src="//s0.wp.com/latex.php?latex=%5CSigma+%3D+%5C%7B0%2C+1%5C%7D&bg=ffffff&fg=000&s=0" alt="\Sigma = \{0, 1\}" title="\Sigma = \{0, 1\}" class="latex"></em>, <i>such that <img decoding="async" src="//s0.wp.com/latex.php?latex=L+%3D+%5C%7Bww%5ER+%7C+w+%5Cin+%5C%7B0%2C+1%5C%7D%5E%2A+%5Ctext%7B+and+%7D+w%5ER+%5Ctext%7B+is+reverse+of+w%7D%5C%7D&bg=ffffff&fg=000&s=0" alt="L = \{ww^R | w \in \{0, 1\}^* \text{ and } w^R \text{ is reverse of w}\}" title="L = \{ww^R | w \in \{0, 1\}^* \text{ and } w^R \text{ is reverse of w}\}" class="latex">. Is <em><img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> regular?</em></i></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Here <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> = {“0”, “1001”, “11011”, … }. <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">  is an infinite language which is a set of (even length) palindromes i.e. the sequences consisting of strings (of 0s and 1s here) followed by the reverse of the same string. Here L has no structure: a sequence can take any form. Thus, we will go by the indirect approach.</p>
<h4 style="text-align:justify;">Proof</h4>
<p style="text-align:justify;">Let us assume that <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> is regular. Consider another language <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27+%3D+%5C%7B0%5Ep110%5Eq+%7C+p%2Cq+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L' = \{0^p110^q | p,q \geq 1\}" title="L' = \{0^p110^q | p,q \geq 1\}" class="latex">. <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27&bg=ffffff&fg=000&s=0" alt="L'" title="L'" class="latex"> is a language consisting of sequences which takes the form: some 0s followed by two 1s which in turn are followed by some 0s. Note that it doesn’t require 0s in the two segments to be equal. It is a regular language as the following automaton (DFA) accepts it.</p>
<p style="text-align:justify;"><img loading="lazy" decoding="async" class="  wp-image-2707 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/12/pl4.png?resize=459%2C181&ssl=1" alt="PL4" width="459" height="181" srcset="https://ritu-kundu.github.io/assets/uploads/2017/12/pl4.png?w=694&ssl=1 694w,https://ritu-kundu.github.io/assets/uploads/2017/12/pl4.png?resize=300%2C118&ssl=1 300w" sizes="(max-width: 459px) 100vw, 459px" data-recalc-dims="1"></p>
<p style="text-align:justify;">As L is a language with a string of 0s and 1s followed by its reverse and L’ is a language of 0s followed by two 1s followed by 0s (which can be seen as a string of 0s ending in 1 followed by another string starting from 1 and followed by 0s). The language resulting from the intersection of these two, say L”, consists of sequences with a segment of 0s followed by a 1 followed by another 1 followed by another segment of equal number of 0s. In other words, <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27%27+%3D+L+%5Ccap+L%27+%3D+%5C%7B0%5Ei110%5Ei+%7C+i+%5Cgeq+1%5C%7D&bg=ffffff&fg=000&s=0" alt="L'' = L \cap L' = \{0^i110^i | i \geq 1\}" title="L'' = L \cap L' = \{0^i110^i | i \geq 1\}" class="latex">. L’ is regular (shown by the DFA) and as per our assumption, L is also regular. Then according to the closure property under intersection, L” should also be regular.</p>
<p style="text-align:justify;">But similar to Problem 2, we can show that L” is not regular using the pumping lemma.</p>
<p style="text-align:justify;"><img decoding="async" src="//s0.wp.com/latex.php?latex=L%27%27&bg=ffffff&fg=000&s=0" alt="L''" title="L''" class="latex"> is infinite and regular. Then according to the pumping lemma, there must exist some <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex"> in <img decoding="async" src="//s0.wp.com/latex.php?latex=%5C%7B0%2C1%5C%7D%5E%2A&bg=ffffff&fg=000&s=0" alt="\{0,1\}^*" title="\{0,1\}^*" class="latex"> such that <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> is non-empty and <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Enz+%5Cin+L+%5Ctext%7B+for+%7D+n+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="xy^nz \in L \text{ for } n \geq 0" title="xy^nz \in L \text{ for } n \geq 0" class="latex">. Every string in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex"> has the above-mentioned form.:  00000….001100000….00). If we try to split up such a string in <img decoding="async" src="//s0.wp.com/latex.php?latex=x&bg=ffffff&fg=000&s=0" alt="x" title="x" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex">, <img decoding="async" src="//s0.wp.com/latex.php?latex=z&bg=ffffff&fg=000&s=0" alt="z" title="z" class="latex">, then a non-empty <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> can take a form from one of the following possibilities: all 0s, zero or more 0s followed by a 11 followed by zero or more 0s, zero or more 0s followed by a 1, or a 1 followed by zero or more 0s.</p>
<p style="text-align:justify;">Now we will show that pumping any of the four types of <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> either disturbs the <em>balance </em>(number of 0s in the two segments) or the <em>structure </em>making it infeasible for the resulting pumped up string to be in L” .</p>
<ul style="text-align:justify;">
<li><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5El&bg=ffffff&fg=000&s=0" alt="y = 0^l" title="y = 0^l" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=l+%5Cgeq+1&bg=ffffff&fg=000&s=0" alt="l \geq 1" title="l \geq 1" class="latex">. This comes from either the first or the second segment. Then <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in more 0s in that segment than the other (violating the balance of 0s in the two segments); therefore, such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27%27&bg=ffffff&fg=000&s=0" alt="L''" title="L''" class="latex">.</li>
<li><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5Ep110%5Eq&bg=ffffff&fg=000&s=0" alt="y = 0^p110^q" title="y = 0^p110^q" class="latex"> for some <img decoding="async" src="//s0.wp.com/latex.php?latex=p%2Cq+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="p,q \geq 0" title="p,q \geq 0" class="latex">. Then any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in a string of 0s, followed by <img decoding="async" src="//s0.wp.com/latex.php?latex=2+%28or%7Ei%29&bg=ffffff&fg=000&s=0" alt="2 (or~i)" title="2 (or~i)" class="latex"> copies of <img decoding="async" src="//s0.wp.com/latex.php?latex=0%5Ep110%5Eq&bg=ffffff&fg=000&s=0" alt="0^p110^q" title="0^p110^q" class="latex">, followed by 0s (i.e. <img decoding="async" src="//s0.wp.com/latex.php?latex=000....0%5Ep110%5Eq0%5Ep110%5Eq.....000&bg=ffffff&fg=000&s=0" alt="000....0^p110^q0^p110^q.....000" title="000....0^p110^q0^p110^q.....000" class="latex"> which destroys the structure); such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.</li>
<li><img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+0%5Ep1&bg=ffffff&fg=000&s=0" alt="y = 0^p1" title="y = 0^p1" class="latex"> (or <img decoding="async" src="//s0.wp.com/latex.php?latex=y+%3D+10%5Ep&bg=ffffff&fg=000&s=0" alt="y = 10^p" title="y = 10^p" class="latex">) for some <img decoding="async" src="//s0.wp.com/latex.php?latex=p+%5Cgeq+0&bg=ffffff&fg=000&s=0" alt="p \geq 0" title="p \geq 0" class="latex">. Then any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5E2z&bg=ffffff&fg=000&s=0" alt="xy^2z" title="xy^2z" class="latex"> (in fact any <img decoding="async" src="//s0.wp.com/latex.php?latex=xy%5Eiz&bg=ffffff&fg=000&s=0" alt="xy^iz" title="xy^iz" class="latex"> for <img decoding="async" src="//s0.wp.com/latex.php?latex=i+%3E+1&bg=ffffff&fg=000&s=0" alt="i > 1" title="i > 1" class="latex">) will result in a string of 0s, followed by <img decoding="async" src="//s0.wp.com/latex.php?latex=2+%28or%7E+i%29&bg=ffffff&fg=000&s=0" alt="2 (or~ i)" title="2 (or~ i)" class="latex"> copies of <img decoding="async" src="//s0.wp.com/latex.php?latex=0%5Ep1&bg=ffffff&fg=000&s=0" alt="0^p1" title="0^p1" class="latex"> (or<img decoding="async" src="//s0.wp.com/latex.php?latex=10%5Ep&bg=ffffff&fg=000&s=0" alt="10^p" title="10^p" class="latex">), followed by 0s and a 1 (i.e. <img decoding="async" src="//s0.wp.com/latex.php?latex=000....0%5Ep10%5Ep100...0000&bg=ffffff&fg=000&s=0" alt="000....0^p10^p100...0000" title="000....0^p10^p100...0000" class="latex"> or <img decoding="async" src="//s0.wp.com/latex.php?latex=000....10%5Ep10%5Ep000...0000&bg=ffffff&fg=000&s=0" alt="000....10^p10^p000...0000" title="000....10^p10^p000...0000" class="latex"> which destroys the structure); such strings can not be in <img decoding="async" src="//s0.wp.com/latex.php?latex=L&bg=ffffff&fg=000&s=0" alt="L" title="L" class="latex">.Hence, there is no <img decoding="async" src="//s0.wp.com/latex.php?latex=y&bg=ffffff&fg=000&s=0" alt="y" title="y" class="latex"> possible that can satisfy the pumping lemma for this language. Thus, <img decoding="async" src="//s0.wp.com/latex.php?latex=L%27%27&bg=ffffff&fg=000&s=0" alt="L''" title="L''" class="latex"> is not regular.</li>
</ul>
<p style="text-align:justify;">Therefore, our initial assumption about L being regular is wrong. Hence, L is non-regular.</p>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>Note that here, in effect, we used 0<sup>i</sup>1 in place of w such that w<sup>R</sup> became 10<sup>i</sup> in L”. To obtain a regular language with the structure of L”, we just obviate the need of two numbers (representing length of the two segments) being equal.</em></p>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>In similar fashion it can be shown that the languages ww or ww<sup>C</sup> (where w<sup>C</sup> is the complement of w obtained by replacing 0 with 1 and vice versa) or any such combination are not regular. We can use the above cheat code of  using 0<sup>i</sup>1 in place of w, then w<sup>C</sup> becomes 1<sup>i</sup>0 in L”.</em></p>
<h2 style="text-align:justify;">Epilogue:</h2>
<p style="text-align:justify;">Please pardon the verbosity, oversimplification, and baby-steps. This part of the post is also more relevant to undergraduate students. Congrats, you made through all the four parts!!.🙂</p>
<p style="text-align:justify;">Cheers!</p>
<p> </p>

</div>
</article>

</main></div>