---
layout: post
title: FSA Part II - Concoction of design-strategies | Ritu Kundu
coltype: no-sidebar
---
<div id="primary" class="featured-content content-area"><main id="main" class="site-main">		
<article id="post-1356" class="posts-entry fbox post-1356 post type-post status-publish format-standard has-post-thumbnail hentry category-algorithm-design-and-analysis">
	<div class="featured-thumbnail">
		<a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/" rel="bookmark"><img width="850" height="423" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?fit=850%2C423&ssl=1" class="attachment-minimalistblogger-slider size-minimalistblogger-slider wp-post-image" alt="" decoding="async" fetchpriority="high" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?w=1261&ssl=1 1261w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=300%2C149&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=768%2C382&ssl=1 768w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=1024%2C510&ssl=1 1024w" sizes="(max-width: 850px) 100vw, 850px"></a>
	</div>
	<header class="entry-header">
		<h1 class="entry-title">FSA Part II: Concoction of design-strategies</h1>
		<div class="entry-meta"><div class="blog-data-wrapper">
			<div class="post-data-divider"></div>
			<div class="post-data-positioning"><div class="post-data-text">
				<span class="posted-on">Posted on <a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/" rel="bookmark"><time class="entry-date published updated" datetime="2017-10-16T00:32:06+00:00">October 16, 2017</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="https://ritu-kundu.github.io/author/rituritukundugmailcom/">Ritu Kundu</a></span></span>
			</div></div>
		</div></div>
	</header>

	<div class="entry-content">
		<p style="text-align:justify;">Again, this post is meant specifically for the undergraduate students (<em>the first timers into the automata theory</em>) – a very brief introduction of FSA: Finite State Automaton (Automata when <em>plural</em>). This post is the second of the four parts: the <a href="https://ritukundu.wordpress.com/2016/12/12/fsa-concoction-of-design-strategies/">first</a> part covers an elementary introduction to FSA and DFA (Deterministic Finite Automaton), this part encompasses some common examples illustrating design-strategies for constructing DFA, <a href="https://ritukundu.wordpress.com/2017/12/12/fsa-part-iii-concoction-of-design-strategies/">Part III</a> provides an introduction to NFA (Nondeterministic Finite Automaton) and its equivalence with DFA, and <a href="https://ritukundu.wordpress.com/2017/12/28/fsa-part-iv-concoction-of-design-strategies/">Part IV</a> introduces Pumping Lemma and its usage in the context of FSA.</p>
<p style="text-align:justify;">The post takes up some examples of various types of problems that can be solved by a  DFA and discusses, for each problem, the approach to design the corresponding DFA. For the cases when the states are comparatively fewer (manageable), we will use the diagrammatic representation (Transition diagram) of the DFA; for others, we will use the mathematical (or formal) description.</p>
<hr>
<hr>
<h1 style="text-align:left;">Type I: Pattern Recognition</h1>
<h2 style="text-align:left;">1. Strings, Substrings & Occurrences</h2>
<p style="text-align:justify;">One set of related problems consists of specification as follows:</p>
<p style="text-align:justify;"><strong>Problem A:</strong> <em>Given an alphabet and a string X (consisting of symbols from the alphabet), DFA should accept</em></p>
<ol style="text-align:justify;">
<li><em>X exactly.</em></li>
<li><em>All strings Y that have X as a substring i.e. input Y contains X somewhere.</em></li>
</ol>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">For example, consider an alphabet Σ = {0,1} and X = 00110.</p>
<p style="text-align:justify;"><strong>Problem A1:</strong> Input should exactly be 00110.</p>
<p style="text-align:justify;">DFA for the example string has been given below. The construction mechanism is similar to the one explained in the <a href="/old-blogs/fsa-concoction-of-design-strategies/">previous</a> post.</p>
<blockquote>
<p style="text-align:justify;"><img decoding="async" class="  wp-image-1466 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p111.png?resize=495%2C144&ssl=1" alt="dfa_eg_p11" width="495" height="144" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p111.png?w=1008&ssl=1 1008w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p111.png?resize=300%2C88&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p111.png?resize=768%2C224&ssl=1 768w" sizes="(max-width: 495px) 100vw, 495px" data-recalc-dims="1"></p>
</blockquote>
<p style="text-align:justify;"><strong>Proble A2:</strong> Input Y = “001<strong>00110</strong>11″ is valid as it contains X (shown as bold) while input Z =  “000111” is invalid.</p>
<p style="text-align:justify;">In this problem, the input does not have to start with “00110” or end after “00110”. Like the previous problem, the states have to remember the symbols of X-like sequence read but unlike it, we can not tell that the input is invalid if the first or second symbols are not 0 or the third and forth are not 1 or the fifth is not 0. “00110” can occur anywhere. Therefore, we do not need the trap-state here. We have to keep looking until we find “00110” and once we have found it, what is remaining of the input will not matter. If we have not found it until the very end of the input, the input is invalid. First symbol of X is 0 which implies that getting a 0 could mean that X might start and that getting a 1 can not start an occurrence of X; therefore, remain in initial state if we get a 1. Thus we get the following:</p>
<blockquote>
<p style="text-align:justify;"><img decoding="async" class="  wp-image-1448 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p131.png?resize=486%2C85&ssl=1" alt="dfa_eg_p13" width="486" height="85" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p131.png?w=1045&ssl=1 1045w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p131.png?resize=300%2C53&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p131.png?resize=768%2C134&ssl=1 768w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p131.png?resize=1024%2C179&ssl=1 1024w" sizes="(max-width: 486px) 100vw, 486px" data-recalc-dims="1"></p>
</blockquote>
<p style="text-align:justify;">The question is where the edge for 1 from S1 or for 0 from S2 and so on should go? Consider one such case – Edge for 0 from S2: It signifies that we have already read 00 but then we were expecting 1 but got 0 ⇒ input read until this instant is …000. 000 can not start X, but last two zeroes could mean that we may find X as X starts from two zeroes. Therefore we should now expect 1 next (two zeroes are followed by 1 in X); this is same as being in the state after reading two zeroes i.e. S2. This edge from S2 should go to S2.</p>
<p style="text-align:justify;">Bingo! that is the trick – Go to the state corresponding to longest prefix of X that happens to be the suffix of sequence on the path from the initial state to the current edge.</p>
<table>
<tbody>
<tr>
<th>edge</th>
<th>sequence on path</th>
<th>X</th>
<th>Longest common suffix of sequence and prefix of X</th>
<th>Next state</th>
</tr>
<tr>
<td align="center">1 from S1</td>
<td align="center">01</td>
<td align="center">00110</td>
<td align="center">0</td>
<td align="center">initial</td>
</tr>
<tr>
<td align="center">0 from S2</td>
<td align="center">0<span style="text-decoration:underline;"><strong>00</strong></span></td>
<td align="center"><span style="text-decoration:underline;"><strong>00</strong></span>110</td>
<td align="center">2</td>
<td align="center">S2 (≡ 00)</td>
</tr>
<tr>
<td align="center">0 from S3</td>
<td align="center">001<span style="text-decoration:underline;"><strong>0</strong></span></td>
<td align="center"><span style="text-decoration:underline;"><strong>0</strong></span>0110</td>
<td align="center">1</td>
<td align="center">S1 (≡ 0)</td>
</tr>
<tr>
<td align="center">1 from S4</td>
<td align="center">00111</td>
<td align="center">00110</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
<p style="text-align:justify;">Finally, we get the DFA as :</p>
<blockquote>
<p style="text-align:justify;"><img loading="lazy" decoding="async" class="  wp-image-1400 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p12.png?resize=581%2C129&ssl=1" alt="dfa_eg_p12" width="581" height="129" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p12.png?w=1049&ssl=1 1049w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p12.png?resize=300%2C67&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p12.png?resize=768%2C171&ssl=1 768w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg_p12.png?resize=1024%2C227&ssl=1 1024w" sizes="(max-width: 581px) 100vw, 581px" data-recalc-dims="1"></p>
</blockquote>
<h5 style="text-align:justify;">Variants:</h5>
<ol style="text-align:justify;">
<li>We can use the above DFA, with slight modification, to find all the occurrences of X<br>
– reaching S5 doesn’t make the remaining input insignificant as we might find another occurrence of X. Thus, edges from S5 will follow the longest suffix-prefix trick (0 to S2 and 1 to initial). We will report every time the final state S5 will be reached while reading the input.</li>
<li>We can use the above DFA (the one to find all the occurrences) to accept all the strings that end with X (For example, accepting 111<strong>00110</strong>, 1010<strong>00110</strong> etc. while rejecting 1100001, 0000000 etc.)</li>
</ol>
<hr>
<h2 style="text-align:left;">2. Substring from the Decimal expansion of a rational number</h2>
<p style="text-align:justify;"><strong>Problem B:</strong> <em>Design a DFA that accepts all strings X such that X is a substring of the decimal expansion of a given rational number.</em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">For example, consider the decimal expansion of  1/7.<br>
As 1/7 = 0.14285714285714… = 0.<span style="border-top:1px solid black;">142857</span></p>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>The decimal expansion of a number is its representation in base-10 (i.e., in the decimal system). For example,</em><br>
<em> 223.15 = 2×10<sup>2</sup> + 2×10<sup>1</sup> + 3× 2<sup>0</sup> + 1×2<sup><span style="font-family:symbol;">–</span>1</sup> + 5×2<sup><span style="font-family:symbol;">–</span>2</sup></em><br>
<em> The decimal expansion of every rational number (of the form p/q) either terminates or eventually start repeating. More mathematical details can be found <a href="http://mathworld.wolfram.com/DecimalExpansion.html" target="_blank" rel="noopener">here</a>.</em></p>
<p style="text-align:justify;">The strings like “0.14”, “0.1428571”, “428”, “8571428571” etc. appear as the substring in the decimal expansion of 1/7. All these strings are valid and should be accepted by the DFA.</p>
<p style="text-align:justify;">Note that this is mirror image of Problem A. In Problem A, we designed the DFA for the shorter sequence (pattern) and the input was the longer sequence (text); whereas, here the DFA is for the longer sequence and the input should be a substring in that.</p>
<h4 style="text-align:justify;">Alphabet of the DFA</h4>
<p style="text-align:justify;"><strong>Σ</strong> is the<strong> </strong>decimal alphabet (i.e. from 0 to 9) including decimal point.</p>
<h4 style="text-align:justify;">What should we remember? (i.e. the states of the DFA)</h4>
<p style="text-align:justify;">The input read so far. Therefore, the states should correspond to “0” (S0), “0.” (S1), “0.1” (S2), “0.14” (S3), “0.142” (S4), “0.1428” (S5), “0.14285” (S6), and “0.142857” (S7). After that the sequence may start repeating (with the digit after the decimal point i.e. starting from 1 and so on) that can be handled by the edges (transition from S7 to S2 on reading 1). All these states represent the final states. The problem is that any of the states can be an initial state (Occurrence of X can start from any of the position in the expansion). Therefore, we need to be careful while defining the initial state and the transitions from it.</p>
<blockquote><p><img loading="lazy" decoding="async" class="alignnone  wp-image-1674" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=606%2C302&ssl=1" alt="DFA_Eg_PB" width="606" height="302" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?w=1261&ssl=1 1261w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=300%2C149&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=768%2C382&ssl=1 768w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_pb.png?resize=1024%2C510&ssl=1 1024w" sizes="(max-width: 606px) 100vw, 606px" data-recalc-dims="1"></p></blockquote>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>Note that the edges leading to the trap state have been labelled as complements of the symbols (meaning any other symbol from the alphabet than the one specified). To simplify the diagrams, we could completely do away with the trap state. Usually, if transition has not been explicitly defined for an input symbol, we can safely assume that there is an implicit edge corresponding to that symbol switching the current state to the trap state.</em></p>
<p style="text-align:justify;">We could simplify the DFA by combining the states S7 and S1 (Resultantly, the edge labelled 7 from S6 will go to S1; edge from initial state to S1 will also be labelled with 7).</p>
<hr>
<h2 style="text-align:justify;">3. Power of 10</h2>
<p style="text-align:justify;"><strong>Problem:</strong> <em>Design a DFA that accepts all strings X over a decimal alphabet (i.e. from 0 to 9) such that X is 10<sup>n</sup> for some n ≥ 1. </em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Any of the strings in the set {“10”, “100”, “1000”, …} is valid. In other words, a valid string should start from 1 and followed by one or more 0. Any other symbol from the alphabet will make the input invalid.  Also, any input not starting from 1 or not ending in a sequence of only zeroes (e.g. “000”, “101”, “111”, “1010”) etc. is invalid.</p>
<h4 style="text-align:justify;">Which states do we need?</h4>
<ol style="text-align:justify;">
<li>One representing that the input begins with 1 [State S1].</li>
<li>Another representing that the initial 1 is followed by one or more 0s [State S10s]. It will also be the final state (representing a valid input).</li>
<li>A trap state representing an invalid input.</li>
</ol>
<p style="text-align:justify;">DFA for the example string has been given below.</p>
<blockquote><p><img loading="lazy" decoding="async" class=" size-medium wp-image-1560 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_p2.png?resize=300%2C173&ssl=1" alt="DFA_Eg_P2" width="300" height="173" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_p2.png?w=606&ssl=1 606w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_p2.png?resize=300%2C173&ssl=1 300w" sizes="(max-width: 300px) 100vw, 300px" data-recalc-dims="1"></p></blockquote>
<h5 style="text-align:justify;"> Variants:</h5>
<ol style="text-align:justify;">
<li>If n ≥ 0 then the input string “1” is also valid; S1 should also be the final state.</li>
<li>If n ≥ k where k is positive integer > 1, then we need (k-1) additional states between S1 and the final one with an edge from one to the next labelled 0.</li>
</ol>
<h1 style="text-align:justify;"></h1>
<hr>
<hr>
<h1 style="text-align:left;">Type II: Testing Computations</h1>
<h2 style="text-align:left;">1. Sum of Two Binary Numbers</h2>
<p style="text-align:justify;"><strong>Problem:</strong> G<em>iven three sequences N1, N2, and S over {0,1}, d</em><em>esign a DFA that tests whether S  represents a valid (correct) binary addition of N1 and N2. </em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Consider the two inputs given below. The input on the left is valid because S represents the correct binary sum of N1 and N2 whereas the one on the right is invalid.</p>
<table border="0" cellspacing="0" align="center">
<tbody>
<tr>
<td align="center" nowrap>N1: 00111<br>
N2: 01010<br>
<span style="border-top:1px solid black;"><br>
S: 10001<br>
</span></td>
<td align="center" nowrap>N1: 00111<br>
N2: 01010<br>
<span style="border-top:1px solid black;"><br>
S: 11101<br>
</span></td>
</tr>
</tbody>
</table>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="text-align:justify;">If we were to test the sum manually,  we will do it column-wise moving from right to left, taking care of any carry generated in the previous operation.</p>
<h4 style="text-align:justify;">Alphabet of the DFA</h4>
<p style="text-align:justify;">One symbol read by the DFA can be represented as a column or triplet of the corresponding bits of each: the first number N1, the second number N2, and the sum S. Resultantly, [b1, b2, s] represents one symbol of the alphabet where each of the b1, b2, and s can be either 0 or 1. Note that only 8 such triplets are possible. Therefore,</p>
<p style="text-align:justify;"><strong>Σ</strong> = {[0 0 0], [0 0 1], [0 1 0], [0 1 1], [1 0 0], [1 0 1], [1 1 0], [1 1 1]}.</p>
<h4 style="text-align:justify;">What should we remember? (i.e. the states of the DFA)</h4>
<p style="text-align:justify;">We need the information whether the previous column led to a carry, in order to test the summation of current column. Thus, we need two states to represent if carry was generated (C) or not (NC). When we start, there is no previous carry. Therefore, the initial state is NC.</p>
<p style="text-align:justify;">To define the transition from each of the two states corresponding to each of the possible input symbol [b1, b2, s], we will add b1 and b2 and the carry information (1 if in C state and 0 if in NC state) and verify if it equals s or not. If the sum is not s, then this column (and hence the overall input) is invalid switching the DFA to the trap state. If it indeed is correct, then the switch will be in accordance with the carry generated by the current column (i.e. if a carry is generated then go to C, otherwise to NC). For instance, consider the transition from C labelled with [0 0 1]. We are in state C (implying that the carry from the previous column is 1). 1 (previous carry) + 0 (b1) + 0 (b2) = 1 which indeed is same as s. Thus it is a valid addition and as this addition doesn’t generate a carry, we must switch to NC state.</p>
<p style="text-align:justify;">If overflow is not allowed, we should end up with no carry being generated by the last column. Therefore, NC is the final state. On the other hand, in case the overflow is ignored, both states are the final states.</p>
<p style="text-align:justify;">The DFA (not allowing an overflow) has been shown below.</p>
<blockquote><p><img loading="lazy" decoding="async" class="  wp-image-1815 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_binarysum.png?resize=458%2C244&ssl=1" alt="DFA_Eg_binarySum" width="458" height="244" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_binarysum.png?w=706&ssl=1 706w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_binarysum.png?resize=300%2C160&ssl=1 300w" sizes="(max-width: 458px) 100vw, 458px" data-recalc-dims="1"><span style="background-color:#ffffff;color:#3d596d;text-align:justify;"> </span></p></blockquote>
<hr>
<h2 style="text-align:justify;">2.Modulus/Multiples</h2>
<p style="text-align:justify;"><strong>Problem:</strong> <em>Design a DFA that accepts all strings X representing a number in a numeral system with base b (e.g. a number in decimal or binary system) such that X<sup>R </sup>(i.e. reverse of the string) is r % (modulus) n, where r and n are decimal numbers.</em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Consider the decimal number system (base b =10). And, <em>X<sup>R</sup> ≡ 5 % 7</em></p>
<p style="text-align:justify;">The string X = “917” should be accepted by the DFA because the reverse of the number ie 719 when divided by 7 gives 5 as the remainder (%). On the other hand “112” is invalid ( since 211 % 7 = 1).</p>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em><span style="text-decoration:underline;">Note 1:</span><br>
The expansion of a number say w of say k digits (w = d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>) in base-b number system is as follows:</em><br>
<em> d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub> = d<sub>k</sub>×b<sup>k-1</sup> + … + d<sub>3</sub>×b<sup>2</sup> + d<sub>2</sub>×b<sup>1</sup> + d<sub>1</sub>×b<sup>0</sup> </em><br>
<em> Remember that,<br>
1. (x + y) % n = ((x % n) + (y % n)) % n<br>
2. x × y % n = ((x % n) × (y % n)) % n</em><br>
Thus, we can compute w % n as follows:<br>
For each term i, such that 0 < i ≤ k,<br>
r<sub>i</sub> = ((d<sub>i</sub> × (b<sup>i-1</sup> % n) % n) + r<sub>i-1</sub>) % n, where r<sub>i</sub> is the remainder of the number up to digit i.<br>
As r<sub>0</sub> = 0, computing from right to left in the above fashion, r<sub>k</sub> will be the final remainder.<br>
<span style="text-decoration:underline;">Note 2:</span><br>
b<sup>i</sup> % n = ((b % n)(b<sup>i-1</sup> % n)) % n</p>
<p style="text-align:justify;">Reading X<sup>R</sup> from right to left is same as reading X left to right.</p>
<h4 style="text-align:justify;">Alphabet of the DFA</h4>
<p style="text-align:justify;"><strong>Σ</strong> is the<strong> </strong>alphabet of the number system.</p>
<h4 style="text-align:justify;">States and the transition function</h4>
<p style="text-align:justify;">To use our strategy, for every i<sup>th</sup> digit read from the input, we should know the remainder r<sub>i-1 </sub> (from the calculations up to that digit) and the result of (b<sup>i-1</sup> % n). As (b<sup>i</sup> % n) will start repeating (periodic/cyclic) after a finite number of steps, we can pre-calculate these terms and remember them. Let us call it p.</p>
<p style="text-align:justify;">Thus a state is a pair (r<sub>i</sub>, p<sub>i</sub>) where p<sub>i</sub> corresponds to (b<sup>i</sup> % n) for some i and r<sub>i</sub> corresponds to one of the possible remainders i.e. from 0 to n-1.</p>
<p style="text-align:justify;">A transition on reading a symbol α from state  (r<sub>i</sub>, p<sub>i</sub>) will take us to the state ( (((αp<sub>i</sub> % n) + r<sub>i</sub>) % n), p<sub>i+1</sub>).</p>
<p style="text-align:justify;">Initial state will be (0, 1) because initial remainder is zero and p<sub>0</sub> = (b<sup>0</sup> % n) = 1.</p>
<p style="text-align:justify;">The final states will be all the states with r<sub>i</sub> = r (irrespective of what the corresponding p<sub>i</sub> is ). It can be represented as  (r, *).</p>
<p style="text-align:justify;">For the given example, b=10, n=7, r=5. Let us calculate p first.</p>
<table>
<tbody>
<tr>
<th>p<sub>i</sub></th>
<th>(b × p<sub>i) % n</sub></th>
<th>p<sub>i+1</sub></th>
</tr>
<tr>
<td align="center">1</td>
<td align="center">(10 × 1) % 7</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">(10 × 3) % 7</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(10 × 2) % 7</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">(10 × 6) % 7</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">(10 × 4) % 7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">(10 × 5) % 7</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p style="text-align:justify;">Thus the DFA can be specified as follows:</p>
<p style="text-align:justify;"><b>ℳ</b> = (<strong>Q, Σ, s, F, δ</strong>) where</p>
<p style="text-align:justify;"><strong>Q</strong> is set of the states (r<sub>i</sub>, p<sub>i</sub>) where r<sub>i </sub>takes values from 0 to 6 and p<sub>i </sub><em>is an element of {1,3,2,6,4,5} (see the table)</em>,</p>
<p style="text-align:justify;"><strong>Σ</strong> is {0,1,….,9},</p>
<p style="text-align:justify;"><strong>s</strong> is <i>(0,1)</i>,</p>
<p style="text-align:justify;"><strong>F</strong> is all states (5, *) [i.e. (5, 1), (5, 3), (5, 2), (5, 6), (5, 4),and  (5, 5)]</p>
<p style="text-align:justify;"><strong>δ </strong>is given as the following transition table:<br>
(r<sub>i</sub>, p<sub>i</sub>)  ——[on reading α from <strong>Σ</strong>] ——> ( (((αp<sub>i</sub> % 7) + r<sub>i</sub>) % n), p<sub>i+1</sub>)<br>
where corresponding p<sub>i+1 </sub>is given in the table above.</p>
<h5 style="text-align:justify;"> Variants:</h5>
<ol style="text-align:justify;">
<li>The string X itself (not its reverse) has to be<i> congruent to r % n </i>(<em>X ≡ r % n</em>).<br>
The strategy to design this DFA makes use of the following way to represent the expanded form of X:<br>
<em><em>d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub> = d<sub>k</sub>×b<sup>k-1</sup> + … + d<sub>3</sub>×b<sup>2</sup> + d<sub>2</sub>×b<sup>1</sup> + d<sub>1</sub>×b<sup>0</sup>  =d<sub>1 </sub>+ b(d<sub>2</sub><sub> </sub>+ b(d<sub>3</sub><sub> </sub>+ b(…..b(d<sub>k</sub>))))<br>
On reading i<sup>th</sup> digit d<sub>i</sub>,  the number becomes w<sub>i </sub>= (b × w<sub>i-1</sub>) +d<sub>i</sub>. Therefore,<br>
w<sub>i </sub>% n =((b  × w<sub>i-1 </sub>% n)  +d<sub>i</sub>) % n.<br>
</em></em>Thus, a state in this case needs to remember the remainder after reading each digit which is from 0 to n-1. Let S<sub>i</sub> be a state corresponding to remainder equal to i. S<sub>i</sub> is the initial state. S<sub>r</sub> is the final state.<br>
The transition function:S<sub>i</sub>  ——[on reading α from <strong>Σ</strong>] ——>S<sub>j</sub> where j = <em>(b  × i<sub> </sub>% n)  + α) % n.</em></li>
<li><em>X is a multiple of n is same as (X ≡ 0 % n)</em><em><br>
</em>For example, following is the DFA that accepts all strings X over {0, 1} (binary system) such that X is the binary representation of a number that is a multiple of 5.<br>
<img loading="lazy" decoding="async" class="  wp-image-2169 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_multiple51.png?resize=357%2C243&ssl=1" alt="DFA_Eg_multiple5" width="357" height="243" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_multiple51.png?w=551&ssl=1 551w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_multiple51.png?resize=300%2C204&ssl=1 300w" sizes="(max-width: 357px) 100vw, 357px" data-recalc-dims="1">Consider the transition from S3 labelled 1: <em>α=1,</em> i =3, j = (( <em>2  × 3)<sub> </sub>% 5)  + 1) % 5</em>) = 2. Thus it switches to S2. We could have pre-calculated the table for (<em>b  × i<sub> </sub>% n</em>) for faster computations.</li>
<li> n=2 is a special case. (<em>X ≡ 0 % 2</em>) means that it is even and (<em>X ≡ 1 % 2</em>) implies that X is odd.</li>
</ol>
<h1 style="text-align:justify;"></h1>
<hr>
<hr>
<h1 style="text-align:left;">Type III: Counting related</h1>
<h2 style="text-align:left;">1. k<sup>th</sup> position from the end</h2>
<p style="text-align:justify;"><strong>Problem:</strong> D<em>esign a DFA that accepts all strings X over an alphabet {0, 1} such that k<sup>th</sup> position of X is 1 where k is a given constant ≥ 1. </em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Let k = 4 i.e. the fourth character from the end of X should be 1. If the length of X is smaller than 4 or the fourth character from the right is 0, it should be invalid. Therefore, input like “1<strong>1</strong>111″, “100<strong>1</strong>010″, “00<strong>1</strong>000″ etc. are valid whereas “10”, “111”, “10111”, “010000” etc. are invalid.</p>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="text-align:justify;">We will remember the last k characters read. Initially, we will keep remembering all the symbols until k symbols have been collected. When we have already read the k symbols, every new symbol will require us to remember that forgetting the first one.</p>
<p style="text-align:justify;">Thus, a state represents a sequence of last k symbols read (d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>). To simplify the specification of the transition function, we can use an extra symbol (let it be ε) to represent an empty position in the sequence of k symbols. The initial state will be a sequence of k empty positions. The final state will have d<sub>k </sub>= 1 (other d<sub>i </sub>do not matter).</p>
<p style="text-align:justify;">The corresponding DFA for the considered example has been specified below:</p>
<p style="text-align:justify;"><b>ℳ</b> = (<strong>Q, Σ, s, F, δ</strong>) where</p>
<p style="text-align:justify;"><strong>Q</strong> is set of the states (d<sub>4 </sub>d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>) such that d<sub>i </sub>takes values from {0, 1, ε} where ε is an symbol representing an empty position in the remembered sequence.</p>
<p style="text-align:justify;"><strong>Σ</strong> is {0, 1},</p>
<p style="text-align:justify;"><strong>s</strong> is <i>(ε ε ε ε)</i>,</p>
<p style="text-align:justify;"><strong>F</strong> is all states (1 d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>)such that d<sub>i </sub>(1 ≤i ≤3) takes values from {0, 1},</p>
<p style="text-align:justify;"><strong>δ </strong>is given as the following transition table:<br>
(d<sub>4 </sub>d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>)  ——[on reading α from <strong>Σ</strong>] ——> (d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>α)</p>
<hr>
<h2 style="text-align:justify;">2. Number of given substrings</h2>
<p style="text-align:justify;"><strong>Problem:</strong> D<em>esign a DFA that accepts all strings X over an alphabet {0, 1} such that it has at least n number of occurrences of substring Y where n is a given constant ≥ 1. </em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Let Y =” 001″  and n = 3 i.e. all the strings that have at least 3 number of occurrences of “001” are valid. Therefore, input like “<strong>001</strong>1<strong>001</strong>0<strong>001</strong>11″, “1<strong>001</strong>00<strong>001</strong>01<strong>001</strong>11<strong>001001″</strong> etc. are valid whereas “10”, “111”, “10111”, “010000”, “<strong>001</strong>1<strong>001</strong>0″ etc. are invalid.</p>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="text-align:justify;">Similar to the problem of k<sup>th</sup> position, we will remember the last k characters read where k is the length of Y. In addition, we need a counter to keep track of the number of occurrences of Y. Every time the current symbol leads to the remembered sequence being equal to Y, we increase the counter by 1 until we reach n. Once we reach n, the input is valid and the rest of the input sequence is irrelevant. We can stop remembering the symbols and updating the counter; staying in that state for the rest of the input.</p>
<p style="text-align:justify;">Thus, a state represents a sequence of last k symbols read (d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>) and counter C. If any d<sub>i</sub> = ε, C will be zero (we increment the counter only after seeing Y). And C = n, only for d<sub>k</sub>…d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>= Y (we stop the increment after that).</p>
<p style="text-align:justify;">The corresponding DFA for the considered example has been specified below:</p>
<p style="text-align:justify;"><b>ℳ</b> = (<strong>Q, Σ, s, F, δ</strong>) where</p>
<p style="text-align:justify;"><strong>Q</strong> is set of the states (d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>; C) such that d<sub>i </sub>takes values from {0, 1, ε} where ε is an symbol representing an empty position in the remembered sequence; and C is a counter (C = 0 if any d<sub>i</sub> = ε; and ford<sub>3</sub>d<sub>2</sub>d<sub>1</sub>= 001, C = 3; otherwise it is in the range 0 to 2),</p>
<p style="text-align:justify;"><strong>Σ</strong> is {0, 1},</p>
<p style="text-align:justify;"><strong>s</strong> is <i>(ε ε ε; 0)</i>,</p>
<p style="text-align:justify;"><strong>F</strong> is all states (0 0 1; 3),</p>
<p style="text-align:justify;"><strong>δ </strong>is given as the following transition table:<br>
(d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>; C)  ——[on reading α from <strong>Σ</strong>] ——> <img loading="lazy" decoding="async" class="  wp-image-2367 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?resize=313%2C56&ssl=1" alt="counter" width="313" height="56" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?w=1665&ssl=1 1665w,https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?resize=300%2C54&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?resize=768%2C138&ssl=1 768w,https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?resize=1024%2C184&ssl=1 1024w,https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?resize=1568%2C282&ssl=1 1568w,https://ritu-kundu.github.io/assets/uploads/2017/10/counter.png?w=1280&ssl=1 1280w" sizes="(max-width: 313px) 100vw, 313px" data-recalc-dims="1"></p>
<h5 style="text-align:justify;">Variants:</h5>
<ol style="text-align:justify;">
<li>If Y must have an occurrence ≤ n, then C = n+1 will make it invalid and act as the trap state. While all the states (d<sub>3 </sub>d<sub>2 </sub>d<sub>1</sub>; C) such that d<sub>i</sub> is<sub> </sub>{0, 1} and C ≤ n will be the final states.</li>
<li>If two or more substrings have been given whose number of occurrences must specify some criteria, we will need that many counters (one corresponding to each Y) and k symbols will be remembered where k is the length of the longest Y. The increment rules will be guided by the relationship of these substrings.</li>
</ol>
<h1></h1>
<hr>
<hr>
<h1 style="text-align:left;">Type IV: Miscellaneous</h1>
<h2 style="text-align:left;">1. Unary numbers</h2>
<p style="border:1px solid #110000;padding:1em;text-align:justify;"><em>A Unary system is base-1 numeral system. The alphabet is a single symbol (arbitrarily chosen 1). To represent a natural number n in this system, 1 will be repeated n times.</em><br>
<em> For example, 5 is represented by 11111 and 2 is represented by 11 in this system.</em></p>
<p style="text-align:justify;"><strong>Problem:</strong> D<em>esign a DFA that accepts all the unary strings X (i.e. over an alphabet {1}) such that X represents a multiple of a constant natural number n.</em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">Let n = 5 i.e. all strings with number of 1s = 5, 10, 15 etc. should be accepted. In other words, a string X  is valid if the length of X  <em>≡ 0 % 5. </em></p>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="text-align:justify;">We need to remember (L % n) where L is the length of the string seen  (correspondingly the number of 1s => the number L). Therefore, states corresponding to every i from 0 to n-1 are required. Each symbol read (i.e. 1) takes us from a state S<sub>i</sub> to the stateS<sub>(i+1)%n</sub>. S<sub>0</sub> is the initial as well as the final state.</p>
<p style="text-align:justify;">The DFA can be shown as:</p>
<blockquote><p><img loading="lazy" decoding="async" class="  wp-image-2431 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_unary.png?resize=457%2C94&ssl=1" alt="DFA_Eg_unary" width="457" height="94" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_unary.png?w=786&ssl=1 786w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_unary.png?resize=300%2C62&ssl=1 300w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_unary.png?resize=768%2C158&ssl=1 768w" sizes="(max-width: 457px) 100vw, 457px" data-recalc-dims="1"></p></blockquote>
<hr>
<h2 style="text-align:justify;">2. Odd/Even Length</h2>
<p style="text-align:justify;"><strong>Problem:</strong> D<em>esign a DFA that accepts all strings X  over an alphabet {0, 1} such that its length is odd (or even).</em></p>
<h4 style="text-align:justify;">Example</h4>
<p style="text-align:justify;">For odd length strings to be valid, inputs like “001” (length = 3), “111”(length = 3), “10101” (length = 5) etc. should be accepted by the DFA whereas “10” (length = 2), “0111” (length = 4) etc. should be rejected.</p>
<h4 style="text-align:justify;">Design strategy</h4>
<p style="text-align:justify;">We need to remember the (L % 2) where L is the length of the string already seen. It will be zero (=> even) or 1 (=> odd). Every symbol read will increase the length by 1, thus switching from even to odd and from odd to even. The corresponding DFA is</p>
<blockquote><p><img loading="lazy" decoding="async" class="  wp-image-2453 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?resize=375%2C98&ssl=1" alt="DFA_Eg_OddLen" width="375" height="98" srcset="https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?w=611&ssl=1 611w,https://ritu-kundu.github.io/assets/uploads/2017/10/dfa_eg_oddlen.png?resize=300%2C79&ssl=1 300w" sizes="(max-width: 375px) 100vw, 375px" data-recalc-dims="1"></p></blockquote>
<h5 style="text-align:justify;">Variants:</h5>
<ol style="text-align:justify;">
<li>For even length (considering 0 to be even), the initial state and the even length state can be combined in one.</li>
<li>DFA that accepts all string X over {0. 1} such that X has odd number of 0s and even number of 1s (or any such combination).<br>
A state will remember the number of 0s % 2 and the number of 1s % 2 i.e. states correspond to (0=odd, 1=odd), (0=odd, 1=even), (0=even, 1=odd), (0=even, 1=even).<br>
Reading a symbol will switch the corresponding counter between even and odd while keeping the other same.</li>
<li>If two or more substrings have been given whose number of occurrences must specify some criteria, we will need that many counters (one corresponding to each Y) and k symbols will be remembered where k is the length of the longest Y. The increment rules will be guided by the relationship of these substrings.</li>
</ol>
<p style="text-align:justify;">This completes the discussion, broadly covering the different types of DFA designing problems. Of course, these can be mixed and matched to solve a general problem. The next part will talk about the non-deterministic finite automaton.</p>
<h2></h2>
<h2>Epilogue:</h2>
<p>Please pardon the verbosity, oversimplification, and baby-steps. This part of the post is also more relevant to undergraduate students. Move onto the next parts .🙂</p>
<p>Cheers!</p>

</div>
</article>

<div id="comments" class="fbox comments-area">
	<h2 class="comments-title">2 thoughts on “<span>FSA Part II: Concoction of design-strategies</span>”</h2>
		<ol class="comment-list">
			<li id="comment-2" class="comment even thread-even depth-1 parent">
			<article id="div-comment-2" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt="" src="https://secure.gravatar.com/avatar/7678495ecd0fd8fdcfe66f2d45303b68?s=32&d=mm&r=g" srcset="https://secure.gravatar.com/avatar/7678495ecd0fd8fdcfe66f2d45303b68?s=64&d=mm&r=g 2x" class="avatar avatar-32 photo" height="32" width="32" loading="lazy" decoding="async">						<b class="fn">Teresa</b> <span class="says">says:</span>					</div>

					<div class="comment-metadata">
						<a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/#comment-2"><time datetime="2017-12-07T17:18:25+00:00">December 7, 2017 at 5:18 pm</time></a>					</div>

									</footer>

				<div class="comment-content">
					<p>Ritu, this has been incredibly helpful, thank you so much for the precious help!! Any chance you will be posting the two remaining parts soon?</p>
				</div>
			</article>
		<ol class="children">
		<li id="comment-3" class="comment byuser comment-author-rituritukundugmailcom bypostauthor odd alt depth-2">
			<article id="div-comment-3" class="comment-body">
				<footer class="comment-meta">
					<div class="comment-author vcard">
						<img alt="" src="https://secure.gravatar.com/avatar/e8cd3e050e6fd2042a75f12ad5334e7e?s=32&d=mm&r=g" srcset="https://secure.gravatar.com/avatar/e8cd3e050e6fd2042a75f12ad5334e7e?s=64&d=mm&r=g 2x" class="avatar avatar-32 photo" height="32" width="32" loading="lazy" decoding="async">						<b class="fn"><a href="http://ritukundu.wordpress.com" class="url" rel="ugc external nofollow">Ritu Kundu</a></b> <span class="says">says:</span>					</div>

					<div class="comment-metadata">
						<a href="/old-blogs/fsa-part-ii-concoction-of-design-strategies/#comment-3"><time datetime="2018-01-03T17:00:57+00:00">January 3, 2018 at 5:00 pm</time></a>					</div>

									</footer>

				<div class="comment-content">
					<p>Thank you Teresa! Hope you find the next two parts beneficial as well.</p>
				</div>

			</article>
		</li>
</ol>
</li>
</ol>

<p class="no-comments">Comments are closed.</p>
		
</div>

</main></div>