---
layout: post
title: FSA Part I - Concoction of design-strategies | Ritu Kundu
coltype: no-sidebar
---
<div id="primary" class="featured-content content-area"><main id="main" class="site-main">		
<article id="post-982" class="posts-entry fbox post-982 post type-post status-publish format-standard has-post-thumbnail hentry category-algorithm-design-and-analysis">
	<div class="featured-thumbnail">
		<a href="/old-blogs/fsa-concoction-of-design-strategies/" rel="bookmark"><img width="669" height="336" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?fit=669%2C336&ssl=1" class="attachment-minimalistblogger-slider size-minimalistblogger-slider wp-post-image" alt="" decoding="async" fetchpriority="high" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?w=669&ssl=1 669w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?resize=300%2C151&ssl=1 300w" sizes="(max-width: 669px) 100vw, 669px"></a>
	</div>
	<header class="entry-header">
		<h1 class="entry-title">FSA Part I: An elementary introduction</h1>
		<div class="entry-meta"><div class="blog-data-wrapper">
			<div class="post-data-divider"></div>
			<div class="post-data-positioning"><div class="post-data-text">
						<span class="posted-on">Posted on <a href="/old-blogs/fsa-concoction-of-design-strategies/" rel="bookmark"><time class="entry-date published updated" datetime="2016-12-12T06:00:23+00:00">December 12, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="https://ritu-kundu.github.io/author/rituritukundugmailcom/">Ritu Kundu</a></span></span>
			</div></div>
		</div></div>
	</header>

	<div class="entry-content">
		<p style="text-align:justify;">Again, this post is meant specifically for the undergraduate students (<em>the first timers into the automata theory</em>) â€“ a very brief introduction of FSA: Finite State Automaton (Automata whenÂ <em>plural</em>). This post is in four parts: this part covers an elementary introductions to FSA and DFA (Deterministic Finite Automaton), <a href="https://ritukundu.wordpress.com/2017/10/16/fsa-part-ii-concoction-of-design-strategies/">Part II</a> encompasses some common examples illustrating design-strategies for constructing DFA, <a href="https://ritukundu.wordpress.com/2017/12/12/fsa-part-iii-concoction-of-design-strategies/">Part III</a> provides an introduction to NFA (Nondeterministic Finite Automaton) and its equivalence with DFA, and <a href="https://ritukundu.wordpress.com/2017/12/28/fsa-part-iv-concoction-of-design-strategies/">Part IV</a> introduces Pumping Lemma and its usage in the context of FSA.</p>
<h1>Finite State Automaton:</h1>
<p style="text-align:justify;">A <em><strong>Finite State Automaton</strong></em>Â (FSA) is a computational model that can be seen asÂ a <em>central control</em>Â which has a set of states associated with it. The word â€˜<em>finite</em>â€˜ in the name depicts that the set of states is finite. The control is given an input â€“ a sequence of symbols from a set called alphabet â€“ and is expected to answer whether the input-sequence is â€˜<em>VALID</em>â€˜ or â€˜<em>INVALID</em>â€˜ after reading the input.</p>
<p style="text-align:justify;">The computational model works as follows: It reads the input starting from the first, until the last â€“ Â one symbol at a time. At eachÂ instant, the control is in one of its possibleÂ states; the particular state in which the control is just when it starts reading the input, is called an <strong><em>initial state.</em></strong>Â With each symbol of the input read, the controlÂ makes a transition (switch) from its current state to another state; the new state does not necessarily have to be a different one i.e. it may switch back to the same state. Â There is a subset of states, called <em><strong>final states</strong></em>, Â representing a â€˜<em>valid</em>â€˜ input; if the control is in one of the final states when it finishes reading the input then it denotes that the input is <em>valid</em>, otherwise not (i.e. <em>invalid</em>).</p>
<h2 style="text-align:justify;">Transition Diagram â€“</h2>
<p style="text-align:justify;">An FSA can be represented graphically by a <em>transition diagram</em> that makes it simpler to visualise and emulate itsÂ working. The associatedÂ transition diagram of a FSA can be drawn as follows:</p>
<ul>
<li>A sate is represented by a circle.Â <img decoding="async" class="  wp-image-1076 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_state.png?resize=38%2C35&ssl=1" alt="dfa_state" width="38" height="35" data-recalc-dims="1"></li>
<li>An initial state by a wedge â€˜>â€™ attached to it.Â <img decoding="async" class="  wp-image-1075 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_initial.png?resize=54%2C40&ssl=1" alt="dfa_initial" width="54" height="40" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_initial.png?w=152&ssl=1 152w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_initial.png?resize=150%2C112&ssl=1 150w" sizes="(max-width: 54px) 100vw, 54px" data-recalc-dims="1"></li>
<li>A final state by a double circle.Â <img loading="lazy" decoding="async" class="  wp-image-1074 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_final.png?resize=48%2C44&ssl=1" alt="dfa_final" width="48" height="44" data-recalc-dims="1"></li>
<li>A transition from one state to another on reading a symbol (say <em>a</em>) by an arc (edge) from the current state to the new one with the symbol as the label of the edge. Â <img loading="lazy" decoding="async" class="  wp-image-1077 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_transition.png?resize=127%2C42&ssl=1" alt="dfa_transition" width="127" height="42" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_transition.png?w=343&ssl=1 343w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_transition.png?resize=300%2C99&ssl=1 300w" sizes="(max-width: 127px) 100vw, 127px" data-recalc-dims="1"></li>
</ul>
<h2>Motivation â€“</h2>
<p style="text-align:justify;">A transition of an FSA depends only on the current state and the symbol of the input-sequence being read. In other words, since a symbol read makes an FSA change its state, the sequence of changes of states corresponds to some <em>property</em> of the input it has read until now. Abstractly, each state of an FSA can be seen to <em>memorise</em>Â someÂ information about the input it has seen so far. Since, the number of states of an FSA is finite, it is said to have a finite â€˜<em>memory</em>â€˜.</p>
<p style="text-align:justify;">AlthoughÂ its finite memory makes the model quite restrictive, yet there are many systems that be modelled using an FSA: A <em>lexer</em>Â (lexical analyser in a compiler) is one such system. Unix/Linux <em>grep</em> command is another utility that makes use of the FSA. Â <em>Find</em> facility of a text-editor â€“ finding a set of <em>strings</em> (sequence of <em>letters</em>) in a longer string (<em>text</em>) â€” is usually implemented using FSA.</p>
<p style="text-align:justify;">Apart fromÂ the direct applications, studying FSA makes it easier to understand and appreciate the more powerful computational models such as <em>Push Down Automaton (PDA)</em> and <em>Turing Machine</em>.</p>
<h2>Classification â€“</h2>
<p style="text-align:justify;">An FSA can be classified as beingÂ <em>deterministic</em>Â orÂ <em>nondeterministic</em>.</p>
<p style="text-align:justify;"><strong><em>Deterministic Finite Automaton (DFA)</em></strong>: Behaviour is deterministic as we can go to only one state (defined by the transition) from the current state on reading a specific symbolÂ (i.e. there is exactly one edge from the current state labelled with a particular symbol). We will be covering DFA in the next section.</p>
<p style="text-align:justify;"><em><strong>Nondeteministic Finite Automaton(NFA):</strong></em> Behaviour is nondeterministic in the sense that on reading a symbol, transitions to many states are defined (i.e. more than one edges are defined from the currentÂ state labelled with the same symbol); control can be in any of the defined states after this transition. In addition <em>empty-transitions</em>Â  (<strong>Îµ</strong>-transitions) are also possible which correspond to changing state <em>without</em> reading a symbol. We shall have a detailed look on NFA in the next post.</p>
<h1>DFA:</h1>
<h2>Â Mathematical description â€“</h2>
<p>Mathematically a DFA can be represented as a 5-tuple <b>â„³</b>Â = (<strong>Q, Î£, s, F, Î´</strong>) where</p>
<p><strong>Q</strong> is finite set of states,</p>
<p><strong>Î£</strong> is an alphabet (set of symbols of the input),</p>
<p><strong>s</strong> âˆˆ <strong>Q </strong>is the initial state,</p>
<p><strong>F</strong> âŠ† <strong>Q</strong>Â is the set of the final states,</p>
<p><strong>Î´</strong> , the transition function, is a function from <strong>Q</strong> Ã—Â <strong>Î£</strong>Â to<strong> Q</strong></p>
<h3>A simple example</h3>
<p style="text-align:justify;">Designing an automaton is to define each element of the tuple. Consider a simple example â€“ <strong>An automaton that accepts a string â€œaabâ€</strong>. Let us assume that the alphabet is {a, b}. It implies that the <em>valid</em> input sequence isÂ exactly â€œaâ€ followed by â€œbâ€ which is followed by another â€œaâ€, after which the input should finish. Anything else is an <em>invalid</em> input. Note that as soon as some symbol making the input invalid is encountered/read, symbols in the remaining inputÂ do not matter as the whole input will be invalid anyway.</p>
<p style="text-align:justify;">For this example,we have to remember that we have seen â€œaâ€ or â€œabâ€, or â€œabaâ€. Also, we should have at least two states â€“ a final state (representing that any given input is valid) to which we should reach only after reading an â€œabaâ€; a trap-state (representing an invalid input) to which we should go to as soon we readÂ any symbol that makes the input invalid and should stay there until the input ends. Once we are in the final state, input should end. What if it does not? We should go to the trap-state, on reading any symbol afterÂ we have reached the final state.</p>
<p>Â <img loading="lazy" decoding="async" class="  wp-image-1262 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_1.png?resize=222%2C200&ssl=1" alt="dfa_eg1_1" width="222" height="200" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_1.png?w=372&ssl=1 372w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_1.png?resize=300%2C271&ssl=1 300w" sizes="(max-width: 222px) 100vw, 222px" data-recalc-dims="1"></p>
<p style="text-align:justify;">When we start reading the input, we are in an initial state. We are expecting an â€œaâ€. If we readÂ an â€œaâ€, we are one step closer to the input being valid => we go to state that remembers that we have read the first â€œaâ€. What if we get a â€œbâ€ at the beginning? It makes the input invalid, we should go to the trap-state.</p>
<p style="text-align:justify;"><img loading="lazy" decoding="async" class="  wp-image-1263 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_2.png?resize=402%2C202&ssl=1" alt="dfa_eg1_2" width="402" height="202" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_2.png?w=669&ssl=1 669w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_2.png?resize=300%2C151&ssl=1 300w" sizes="(max-width: 402px) 100vw, 402px" data-recalc-dims="1"></p>
<p style="text-align:justify;">Now , after reading the first â€œaâ€, we are expecting a â€œbâ€. If we get a â€œbâ€, we are one more step close to the final state; ab we should remember reading an â€œabâ€. If we get an â€œaâ€ as the second symbol (i.e the input starts from â€œaaâ€), Â it is an invalid input.</p>
<p><img loading="lazy" decoding="async" class="  wp-image-1264 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_3.png?resize=412%2C207&ssl=1" alt="dfa_eg1_3" width="412" height="207" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_3.png?w=669&ssl=1 669w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_3.png?resize=300%2C151&ssl=1 300w" sizes="(max-width: 412px) 100vw, 412px" data-recalc-dims="1"></p>
<p style="text-align:justify;">The third expected symbol is an â€œaâ€, getting which we should reach the final state. If we get a â€œbâ€ instead, it makes the valid input.</p>
<p style="text-align:justify;"><img loading="lazy" decoding="async" class="  wp-image-1265 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?resize=426%2C214&ssl=1" alt="dfa_eg1_4" width="426" height="214" srcset="https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?w=669&ssl=1 669w,https://ritu-kundu.github.io/assets/uploads/2016/11/dfa_eg1_4.png?resize=300%2C151&ssl=1 300w" sizes="(max-width: 426px) 100vw, 426px" data-recalc-dims="1"></p>
<p style="text-align:justify;">After reaching the final state, any additional symbol will lead to the trap-stateÂ state and control will be trapped there until the end of the input. As the trap-state is not final, it will indicate that the input is invalid. On the other hand, if the input finishes as soon as we reach the state representing â€œabaâ€, it will indicate a valid input as this state is final.</p>
<p style="text-align:justify;">Mathematically, the DFA can be expressed as follows:</p>
<p style="text-align:justify;"><b>â„³</b>Â = (<strong>Q, Î£, s, F, Î´</strong>) where</p>
<p style="text-align:justify;"><strong>Q</strong> is {<em>0, a, ab, aba, trap-state</em>} (naming initial state to be 0),</p>
<p style="text-align:justify;"><strong>Î£</strong> is {â€œaâ€, â€œbâ€},</p>
<p style="text-align:justify;"><strong>s</strong>Â is <em>0</em>,</p>
<p style="text-align:justify;"><strong>F</strong> is {<em>aba</em>}</p>
<p style="text-align:justify;"><strong>Î´ </strong>is given as the following transition table:</p>
<table style="height:247px;" width="573">
<tbody>
<tr>
<th>input symbolÂ â†’<br>
state â†“</th>
<th>â€œaâ€</th>
<th>â€œbâ€</th>
</tr>
<tr>
<td><strong><em>0</em></strong></td>
<td><em>a</em></td>
<td><em>trap-state</em></td>
</tr>
<tr>
<td><em><strong>a</strong></em></td>
<td><em>trap-state</em></td>
<td><em>ab</em></td>
</tr>
<tr>
<td><em><strong>ab</strong></em></td>
<td><em>aba</em></td>
<td><em>trap-state</em></td>
</tr>
<tr>
<td><em><strong>aba</strong></em></td>
<td><em>trap-state</em></td>
<td><em>trap-state</em></td>
</tr>
<tr>
<td><em><strong>trap-state</strong></em></td>
<td><em>trap-state</em></td>
<td><em>trap-state</em></td>
</tr>
</tbody>
</table>
<p>Working of the FSA for some input sequences are shown in the following (current symbol being considered is shown in red; current state in green; edge taken and the next state in red):</p>
<ul>
<li>A valid sequence</li>
</ul>
<p><img loading="lazy" decoding="async" class="  wp-image-1319 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/output_rlnv5i.gif?resize=459%2C307&ssl=1" alt="output_rlnv5i" width="459" height="307" data-recalc-dims="1"></p>
<ul>
<li>An invalid seqeunce: does not end after â€œabaâ€<br>
<img loading="lazy" decoding="async" class="  wp-image-1331 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/output_tuxqun.gif?resize=412%2C276&ssl=1" alt="output_tuxqun" width="412" height="276" data-recalc-dims="1"></li>
<li>An invalid sequence: not equal to â€œabaâ€</li>
</ul>
<p><img loading="lazy" decoding="async" class="  wp-image-1334 aligncenter" src="https://ritu-kundu.github.io/assets/uploads/2016/11/output_pfnn4i.gif?resize=409%2C274&ssl=1" alt="output_pfnn4i" width="409" height="274" data-recalc-dims="1"></p>
<p>Â </p>
<h2>Epilogue:</h2>
<p>Please pardonÂ the verbosity, oversimplification, and baby-steps. This particular part of the post is more relevantÂ to undergraduate students. Move onto the next partsÂ .ğŸ™‚</p>
<p>Cheers!</p>
<p>Â </p>

</div>
</article>

</main></div>